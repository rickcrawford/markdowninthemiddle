# Markdown in the Middle - HTTPS Proxy Configuration

# Proxy listener settings
proxy:
  # Address to listen on
  addr: ":8080"
  # Read/write timeouts
  read_timeout: 30s
  write_timeout: 30s

# TLS settings
tls:
  # Enable TLS on the proxy listener
  # When enabled, MITM is automatically activated (no separate flag needed)
  enabled: true
  # Path to TLS cert file (if not using auto-generated)
  cert_file: ""
  # Path to TLS key file (if not using auto-generated)
  key_file: ""
  # Auto-generate a self-signed certificate
  auto_cert: true
  # Self-signed cert options
  auto_cert_host: "localhost"
  auto_cert_dir: "./certs"
  # Skip TLS certificate verification for upstream requests
  insecure: false

# Conversion settings
conversion:
  # Enable HTML to Markdown conversion
  enabled: true
  # TikToken encoding for token counting
  tiktoken_encoding: "cl100k_base"
  # Only convert when client sends Accept: text/markdown (content negotiation mode)
  negotiate_only: false

# Response body size limit (bytes). 0 = unlimited.
max_body_size: 10485760  # 10 MB

# Cache settings
cache:
  # Enable response caching
  enabled: false
  # Directory to store cached HTML files
  dir: ""
  # Respect RFC cache-control headers
  respect_headers: true

# Output settings - write converted Markdown to files
output:
  # Enable writing Markdown output files
  enabled: false
  # Directory to write .md files (file-safe names derived from URL)
  dir: ""

# Transport settings
transport:
  # Transport type for fetching upstream content
  # "http" - standard net/http transport (reverse proxy behavior)
  # "chromedp" - headless Chrome via Chrome DevTools Protocol (JavaScript rendering)
  type: "chromedp"
  # chromedp transport configuration (only used when type: "chromedp")
  chromedp:
    # Chrome DevTools Protocol URL
    # Docker: http://chrome:9222 (service name from docker-compose.yml)
    # Local: http://localhost:9222 (if Chrome running on host machine)
    url: "http://chrome:9222"
    # Max concurrent tabs in the browser pool (default: 5)
    pool_size: 5

# Request filtering - restrict which URLs the proxy will handle
filter:
  # List of Go regex patterns. If non-empty, only matching URLs are proxied.
  # Empty list = allow all requests.
  # Each pattern is matched against the full URL (scheme://host/path?query)
  allowed: []
  # Examples:
  #   - "^https://api\\.example\\.com/"          # Allow specific API domain
  #   - "^https://(www\\.)?example\\.com/docs/"  # Allow docs on example.com or www.example.com
  #   - "^https://example\\.com"                 # Allow all on example.com
  # Non-matching URLs return HTTP 403 Forbidden

# Logging
log_level: "info"
